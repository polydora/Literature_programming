---
title: "Знакомство с R"
author: "Марина Варфоломеева"
output:
  html_document:
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("knitcitations")
cleanbib()
options("citation_format" = "pandoc")

# Knitr hooks
knitr::knit_hooks$set(
  hide_button = function(before, options, envir) {
    if (is.character(options$hide_button)) {
      button_text = options$hide_button
    } else {
      button_text = "Решение"
    }
    block_label <- paste0("hide_button", options$label)
    if (before) {
      return(paste0(sep = "\n",
                   '<button class="btn btn-primary btn-sm" data-toggle="collapse" data-target="#', block_label, '"> ', button_text, ' </button>\n',
                   '<div id="', block_label, '" class="collapse">\n'))
    } else {
      return("</div><br />\n")
    }
  },
  output = function(x, options){
    x <- gsub(x, pattern = "<", replacement = "&lt;")
    x <- gsub(x, pattern = ">", replacement = "&gt;")
    paste0(
      "<pre class=\"r-output\"><code>",
      fansi::sgr_to_html(x = x, warn = TRUE, term.cap = "256"),
      # ansistrings::ansi_to_html(text = x, fullpage = FALSE),
      "</code></pre>"
    )
  }
)

```


```{css, echo=FALSE}
.spoiler {
  visibility: hidden;
}

.spoiler::before {
  visibility: visible;
  content: "ОТВЕТ (наведите указатель, чтобы увидеть)"
}

.spoiler:hover {
  visibility: visible;
}

.spoiler:hover::before {
  display: none;
}
```

## Организация рабочего пространства

1. Создайте папку, где будут храниться ВСЕ материалы курса. Например:  Мы будем ее называть __рабочей директорией__. В эту папку помещайте ВСЕ файлы с кодом (с расширением .R).
2. Внутри папки `linmodr` создайте папку `data`, где будут храниться все файлы с данными для анализа.

В итоге у вас должно получиться примерно это:

```
C:\linmodr\
C:\linmodr\data\
```

## Настройка RStudio

Все настройки RStudio находятся меню Tools -> Global Options

- Восстановление рабочено пространства из прошлого сеанса --- это лучше отменить, т.к. обычно переменные-призраки очень мешают. На вкладке `General` убираем галочку `Restore .RData into workspace at startup`, и меняем `Save workspace to .RData on exit` - `Never`
- Перенос длинных строк в окне кода --- это удобно. На вкладке `Code` ставим галочку рядом с опцией `Soft-wrap R source files`

## Комментарии

Комментарии в текстах программ обозначаются символом `#`

```{r}
# это комментарии, они не будут выполняться
```

## Полезные клавиатурные сокращения в RStudio

- `Ctrl + Shift + C` - закомментировать/раскомментировать выделенный фрагмент кода
- `Ctrl + Enter` - отправляет строку из текстового редактора в консоль, а если выделить несколько строк, то будет выполнен этот фрагмент кода.
- `Tab` или `Ctrl + Space` - нажмите после того как начали набирать название функции или переменной, и появится список автоподстановки. Это помогает печатать код быстро и с меньшим количеством ошибок.

## R как калькулятор, математические операции

Математические операторы `+ - / * ^`

```{r}
2 + 2
1024 / 2
1:10
34 * 4
2 ^ 4
```

#### Задание 1

Поэкспериментируйте с другими математическими операторами (+ - / * ^).

```{r purl=FALSE, hide_button=TRUE}
sqrt(-1) # NaN - "не число"
1 / 0    # Inf - бесконечность
# sqt(9) # ошибка

# Скобки регулируют порядок операций
2 + 3 * 4
(2 + 3) * 4

# Корни других степеней
27 ^ (1 / 3) # кубический корень
16 ^ (1 / 4) # корень 4-й степени
16 ^ 1 / 4   # осторожно, без скобок сначала будет выполнено 16 ^ 1, а потом деление
```


Для некоторых операций в R есть функции, например:

```{r}
sqrt(27)
log(100)
log10(100)
```

#### Задание 2

Найдите длину гипотенузы прямоугольного треугольника со сторонами 3 и 5 см.

```{r purl=FALSE, hide_button=TRUE}
sqrt(3^2 + 5^2)
```


## Как получить помощь

1. В RStudio можно поставить курсор на слово `sqrt` и нажать `F1`
2. Перед названием функции можно напечатать знак вопроса и выполнить эту строку
`?sqrt`
3. Можно воспользоваться функцией `help()`

```{r eval=FALSE}
help("sqrt")
```



## Переменные

Переменные -- это "контейнеры" для числовых (и разных других) значений.

Имена переменных могут содержать латинские буквы обоих регистров, символы точки `.` и подчеркивания `_`, а так же цифры. Имена переменных должны начинаться с латинских букв. Создавайте понятные и "говорящие" имена переменных.

Оператор присваивания это символ стрелочки `<-`. Он работает справа налево, это значит, что значение выражения в его правой части присваивается объекту в левой части.

Создаем переменную a и присваиваем ей значение 2, и переменную b со значением 5:

```{r}
a <- 2
b <- 5
```

Переменные можно вызвать по имени:

```{r}
a
b
```

С переменными можно проводить разные операции

```{r}
a ^ b
a * 3 + sqrt(9) / b
```

Как выбрать название переменной?

- `a` - плохо, и даже `b`, или `х`. Но в некоторых случаях допустимо:)
- `var1` - плохо, но уже лучше
- `var_1` - плохо, но уже лучше
- `shelllength` - говорящее, но плохо читается
- `shell_length`, `wing_colour` или `leg_num` - хорошие говорящие и читабельные названия

Осторожно, переменные можно случайно или намеренно перезаписать. Пока что b было равно `r 5`, но если мы присвоим переменной b другое значение --- оно изменится.

```{r}
b
b <- 10 + 3
b
```

Код --- это линейная последовательность действий. 
Переменные можно использовать только после того, как они были созданы.

Пример 1

```{r eval=FALSE}
box_weight <- 1.5
apples <- 6
box / apples # ошибка. переменная box еще не была создана.
# нужная переменная называется box_weight.
```

Пример 2

```{r eval=FALSE}
box <- 1.3
box / fruits # ошибка. переменная fruits еще не была создана.
fruits <- 7
```

#### Задание 3

Переставьте строки так, чтобы код можно было выполнить без ошибки.

```{r eval=FALSE}
distance <- 149
speed <- distance / time
time <- 5
```

```{r purl=FALSE, hide_button=TRUE}
distance <- 149
time <- 5                # сначала создаем переменную time
speed <- distance / time # только потом ее используем
```

#### Задание 4

Представьте прямоугольник. Его ширина 3 см, а длина на 5 см больше. Чему равен периметр? (В решении используйте переменные).

```{r purl=FALSE, hide_button=TRUE}
width <- 3               # Ширина
len <- width + 5         # Длина
per <- 2 * (width + len) # Периметр
```


## Структуры данных

Данные в R можно хранить в виде разных объектов.

В результате выполнения следующих команд числа. Одно выражение - одно значение.

```{r}
23
sqrt(25)
```

На самом деле, эти величины - просто векторы единичной длины

Сначала разберемся с векторами, а другие структуры данных (датафреймы, списки, матрицы) будем изучать по мере знакомства с R .

## Векторы

_Вектор_ - один объект, внутри которого несколько значений.

### Создание векторов при помощи `:`

Оператор `:` (двоеточие) используется для создания векторов, где значения следуют одно за другим с шагом 1 без пропусков.

```{r}
1:10 # от одного до 10
-5:3 # от -5 до 3
```

#### Задание 5

Создайте вектор из целых чисел от 1 до 100. Как вы думаете, что означают номера в квадратных скобках в начале каждой строки?

```{r purl=FALSE, hide_button=TRUE}
1:100 
# Номера в квадратных скобках - порядковый номер первого элемента строки
```

### Создание векторов при помощи `c()`

Функция `c()` - от англ. concatenate. Следите, чтобы было английское си, а не русское эс:).

```{r eval=FALSE}
?c # посмотрите хелп к функции
```

Функция `c` принимает несколько (произвольное количество) аргументов, разделенных запятыми. Она собирает из них вектор.

```{r}
c(2, 4, 6)
c(-9.3, 0, 2.17, 21.3)
```

#### Задание 6

Создайте вектор, в котором будет три наименьших отрицательных простых числа в порядке возрастания.

```{r purl=FALSE, hide_button=TRUE}
# Решение
c(-3, - 2, -1)
-3:-1
```

### Создание векторов при помощи `seq()`

Функция `seq()` создает последовательности с заданным шагом или заданной длины.

```{r}
seq(from = 1, to = 5, by = 0.5)
```

Если вы посмотрите в справку к `seq()`, то увидите, что в шаблоне ее вызова перечислены аргументы в определенном порядке: from, to, by и так далее.

```{r eval=FALSE}
?seq
```


В R можно вызывать функцию не только указывая ее аргументы с именами, но и просто в том порядке, в котором они следуют в шаблоне. Поэтому другой вариант кода даст тот же результат:

```{r}
seq(1, 5, 0.5)
```

Так можно поступать лишь с элементарными функциями. Если вы делаете что-то сложное, лучше назовите аргументы по именам --- ваш код будет легче читать.


#### Задание 7

Посмотрите в справку к функции `seq()` и выясните, как создавать последовательности заданной длины.
Создайте последовательность от -1 до 1 из 9 элементов.

```{r purl=FALSE, hide_button=TRUE}
seq(from = -1, to = 1, length.out = 9)
```

Векторы можно хранить в переменных для последующего использования

```{r}
my_num <- -4:4 # численный вектор от -4 до 4 сохранен в переменной my_num
my_num
my_num_1 <- c(100, 200, 300, 400) # численный вектор в переменной my_num_1
my_num_1
my_num_2 <- c(1.3, 1.7, 1.2, 0.4)
my_num_2
```

#### Задание 8

- Создайте вектор `nums`, в котором сначала следуют все элементы вектора `my_num`, а затем все элементы вектора `my_num_1`.
- Создайте вектор `nums_2, в котором сначала идут элементы `my_num`, а потом `my_num_2`.

```{r purl=FALSE, hide_button=TRUE}
# Первая часть задания
# Вариант 1. Можно просто перечислить все элементы
nums <- c(-4:4, 100, 200, 300, 400)
# Вариант 2. Можно использовать уже созданные векторы
nums <- c(my_num, my_num_1)
nums

# Вторая часть задания
nums_2 <- c(my_num, my_num_2)
nums_2
```

### ПривЕдение типов (маленькое и дружелюбное)

Посмотрите внимательно на вектор my_num, который мы только что создали.

```{r}
my_num_2
```

Произошло (без нашего ведома) приведение типов данных (от слова "приводить"). При объединении в один вектор данные должны были быть приведены к одному и тому же типу, поэтому целые числа превратились в дробные. И это хорошо, что не наоборот --- так мы не потеряли точность.

Мы еще не раз столкнемся с приведением типов. К счастью, в большинстве случаев нас будет устраивать то, что R делает сам и нам почти никогда не придется делать приведение типов в явном виде.

### Векторизованные операции

Со всеми элементами вектора можно разом делать одинаковые операции. Это называется "векторизованные операции". Математические операции и многие функции векторизованы, это значит, что вам не придется перебирать элементы вектора, чтобы сделать с ними повторяющиеся действия. Посмотрим, как это выглядит на примере:

```{r}
# Создадим переменную, для хранения вектора
v1 <- 1:9
v1 # так можно посмотреть, что у нее внутри
# С векторами можно делать множество операций - это удобно
v1 + 5
v1 / 2
2 / v1
```

### Адресация внутри векторов

При помощи оператора `[]`, можно обратится к элементам вектора. 
В квадратных скобках вам нужно указать __вектор из одного или нескольких индексов__ --- порядковых номеров элементов.

Если вам нужен один элемент, все просто:

```{r}
nums[1] # первый элемент в векторе nums
nums[10] # 10-й элемент
nums[16]
```

А если вам нужно несколько элементов?

Вектор --- одномерный объект. У его элементов только один порядковый номер (индекс). Поэтому при обращении к элементам вектора нужно указывать только одно число или один вектор с адресами, как мы это делали в предыдущих примерах. Но R выдаст ошибку, если при обращении к вектору, вы не создавали вектор, а просто перечислили номера элементов через запятую.

```{r eval=FALSE}
nums[2, 4, 6] # ошибка!
```

Если вам нужно несколько элементов, то их нужно передать квадратным скобкам __в виде вектора__.


```{r}
# Несколько элементов
nums[c(2, 4, 6)] # возвращает 2-й, 4-й и 6-й элементы
# Несколько элементов подряд
nums[3:5]
```

#### Задание 9

Извлеките из вектора nums элементы:

- с 10 по 13
- 1, 3, и 5
- с 1 по 3 и 13

```{r purl=FALSE, hide_button=TRUE}
# - с 10 по 13
nums[10:13]
# - 1, 3, и 5
nums[c(1, 3, 5)]
# - с 1 по 3 и 13
nums[c(1:3, 13)]
```

#### Задание 10

Что будет, если в квадратных скобках указать отрицательный индекс элемента?

- `-13`
- `-1`
- `-c(1:3, 13)`

И что будет, если обратится к элементу с номером, больше, чем число элементов в векторе?

- Например, с номером `42`.

```{r purl=FALSE, hide_button=TRUE}
# Отрицательные индексы используются для исключения элементов
nums[-13] # без 13-го элемента
nums[-1] # без 1-го элемента
nums[-c(1:3, 13)] # без элементов 1, 2, 3 и 13
# Это потому, что `-c(1:3, 13)` превратится в вектор отрицательных чисел
-c(1:3, 13)

# При обращении к несуществующему элементу получается `NA`
nums[42]
```

## Встроенные константы в R

Встроенные константы в R: NA, NULL, NAN, Inf

- NA - англ "not available". Когда объект был, но его свойство не измерили или не записали.
- NULL - пусто - просто ничего нет
- NaN - "not a number"
- Inf - "infinity" - бесконечность

Если попросили добыть из вектора номер элемента, которого там точно нет, то R выдаст `NA`, потому, что такого элемента нет.

Теперь посмотрим на встроенные константы в действии.

Создаем новый вектор с пропущенным значением для экспериментов.

```{r}
my_NA <- c(1, 3, NA, 9, 0, 27)
```

Вот так он выглядит:

```{r}
my_NA
```

Что произойдет с NA?

```{r}
my_NA + 2  # останется NA
my_NA * 0  # останется NA
my_NA / 0  # останется NA
```

Но в последнем случае вы увидите 

- Inf при делении чисел на ноль
- NaN при делении нуля на ноль

NaN получится, если взять корень из отрицательного числа

```{r}
sqrt(-1)
```


## Некоторые типы данных в R

### Числовые данные

Только что видели

### Текстовые данные

Каждый текстовый элемент (говорят "строка" - string, character) должен быть окружен кавычками - двойными или одинарными.

```{r}
"это текст"
'это тоже текст'
"2" # это тоже текст
```

С обычным текстом нельзя работать как с числом, но некоторый текст может превращаться в число.

```{r eval=FALSE}
"2" + 2 # ошибка
```

Можно принудительно превратить число в кавычках в числовые данные.
```{r}
as.numeric("2") # принудительное приведение типов
# После этого можно использовать математические операции.
as.numeric("2") + 2
```

При этом нельзя превратить обычный текст в число

```{r eval=FALSE}
as.numeric("это текст")
```

Текстовые значения можно объединять в векторы и работать с ними как обычно. Давайте попробуем поэкспериментировать.

#### Задание 11

Создайте вектор rainbow с названиями цветов радуги.
Добудьте из этого вектора при помощи `[]` элементы 1 и 6.

```{r purl=FALSE, hide_button=TRUE}
rainbow <- c("red", "orange", "yellow", "green", "blue", "violet")
rainbow # Распечатываем весь вектор.
rainbow[c(1, 6)] # Добываем элементы 1 и 6.
```

### Логические данные

```{r}
TRUE # истина
FALSE # ложь
```

Для ленивых - можно сокращать первыми заглавными буквами. Но лучше так не делать, чтобы читать программы было легче.

```{r}
c(T, F)
```

Для проверки условий используются операторы сравнения и сопоставления `==  <  >  <=  >=  %in%`.

Логические операторы используются для объединения результатов нескольких проверок: И - `&`,  ИЛИ - `|`,  НЕ - `!`

```{r}
?Comparison # справка об операторах сравнения
?match      # о сопоставлении
?Logic      # Справка о логических операторах
```

Давайте представим, что перед нами несколько чашек с чаем. В них разное число кусков сахара и разная температура. И чай в них черный или зеленый.

```{r}
sugar <- c(1, 3, 0, 2, 3, 4, 1, 0, 5, 0)
temp <- c(40, 50, 22, 22, 53, 41, 35, 47, 55, 52)
tea <- c('B', 'B', 'G', 'B', 'B', 'B', 'G', 'G', 'G', 'B')
```

В векторах `sugar`, `temp` и `tea` информация об одних и тех же чашках в одинаковом порядке. Такие векторы мы назовем "сопряженные".

```{r}
# В каких чашках два или меньше кусков сахара?
sugar <= 2
# В каких чашках температура больше 40 градусов?
temp > 40
sum(temp > 40)
which(temp > 40)
```

Теперь посмотрим на логические операторы.

```{r}
# В каких чашках эти условия выполняются одновременно?
(sugar <= 2) & (temp > 40)
# А если мы хотим знать, в каких чашках мало сахара или большая температура?
(sugar <= 2) | (temp > 40)
```

Важный логический оператор --- отрицание `!` (восклицательный знак). 

```{r}
# Логические значения превращаются в свою противоположность.
! TRUE
! FALSE
# С векторами происходит то же самое
temp > 40
! (temp > 40)
```


#### Задание 12 

При помощи логических векторов ответьте на эти вопросы:

- В каких чашках нет сахара?
- В каких чашках холодный чай (меньше 40 градусов)?
- В каких чашках 0, 3 или 5 кусков сахара?
- В каких чашках нет сахара и чай горячий (больше 40 градусов)?

```{r purl=FALSE, hide_button=TRUE}
# - В каких чашках нет сахара?
sugar == 0
# - В каких чашках холодный чай (меньше 40 градусов)?
temp < 40
# - В каких чашках 0, 3 или 5 кусков сахара?
sugar == 0 | sugar == 3 | sugar == 5
sugar %in% c(0, 3, 5) # то же самое, но короче
# - В каких чашках нет сахара и чай горячий (больше 40 градусов)?
(sugar == 0) & (temp > 40)
```

Логические векторы можно использовать в [], чтобы отобрать данные, соответствующие условию.

```{r}
# Какого цвета чай в чашках с температурой > 50 градусов?
tea[temp > 50]
# Какой температуры зеленый чай в этих чашках?
temp[tea == 'G']
```

#### Задание 13

При помощи логических векторов отберите нужные данные:

- цвет чая, в котором нет сахара
- температура чая, в котором три или больше кусков сахара
- цвет чая, в котором 0, 3 или 5 кусков сахара

```{r purl=FALSE, hide_button=TRUE}
# - цвет чая, в котором нет сахара
tea[sugar == 0]
# - температура чая, в котором три или больше кусков сахара
temp[sugar >= 3]
# - цвет чая, в котором 0, 3 или 5 кусков сахара
tea[(sugar == 0) | (sugar == 3) | (sugar == 5)]
tea[sugar %in% c(0, 3, 5)]
```


### Факторы

Факторы - это способ хранения дискретных (=категориальных данных). Например, если вы поймали 10 улиток и посмотрели их цвет. У большого количества улиток небольшое счетное количество возможных цветов.

```{r}
snails <- c("r", "r", "r", "y", "y", "g", "g", "g", "g")
snails # это просто вектор
```

Но цвет "желтый" обозначает одно и то же для каждой из улиток. Поэтому в целях экономии места можно записать цвета этих улиток в виде вектора, в котором численным значениям будут сопоставлены "этикетки" (называются "уровни" - levels) - названия цветов. Мы можем создать "фактор" цвет улиток.

```{r}
f_snails <- factor(snails)
f_snails # это фактор
```

уровни (levels) этого фактора

- 1 - g,
- 2 - r,
- 3 - y

По умолчанию, R назначает порядок уровней по алфавиту. Можно изменить порядок (см. `help("factor")`). Нам это пригодится позже для работы с дискретными переменными.


Факторы особенно полезны, когда у вас дискретный признак записан числами. Например, вы записали цвет улиток номерами оттенков Pantone (это фантастические улитки, все их цвета из палитры C, поэтому мы записали их только числами).

```{r}
snails_pantone <- c(485, 485, 485, 102, 102, 2286, 2286, 2286, 2286)
```

Для R это просто числа, поэтому он простодушно может посчитать сумму этих чисел или даже разделить их на какое-то число. Хотя такие операции с цветами улиток не имеют смысла.

```{r}
sum(snails_pantone)
snails_pantone / 2
```

Правильно было бы сказать R, что `snails_pantone` --- это фактор, и там содержаться просто какие-то дискретные значения.

```{r}
f_snails_pantone <- factor(snails_pantone)
f_snails_pantone
```

Арифметические операции с фактором вызовут ошибки и предупреждения --- это как раз то, чего мы хотели.

```{r eval=FALSE}
sum(f_snails_pantone) # ошибка
f_snails_pantone / 2  # вектор NA и предупреждение
```

## Функции в R

Вы уже видели массу функций, их легко узнать по скобкам после ключевого слова. Познакомимся еще с несколькими и научимся писать пользовательские функции. Пользовательские функции позволяют автоматизировать повторяющиеся действия и делают код легко читаемым.

Вот наш вектор

```{r}
nums
```

Длину вектора можно вычислить при помощи функции `length()`

```{r}
length(nums)
```

Сумму элементов вектора при помощи функции `sum()`

```{r}
sum(nums)
```

#### Задание 14

Вычислите среднее значение для вектора `nums`. Вначале попробуйте сделать это "вручную" при помощи функций `length()` и `sum()`. Как вы думаете, как называется функция, которая может это сделать сразу?

```{r purl=FALSE, hide_button=TRUE}
sum(nums)/length(nums)
mean(nums)
```

Сумма не работает, если в векторе есть `NA`.

```{r}
my_NA
length(my_NA)
sum(my_NA)
```

Чтобы узнать, почему и как это исправить - посмотрите в `help("sum")`. 
Выяснится, что у функции `sum()` есть аргумент `na.rm`, который по умолчанию принимает значение `FALSE`, то есть `NA` не учитываются при подсчете суммы.

Если мы передадим функции `sum` аргумент `na.rm = TRUE`, то получится правильная сумма

```{r}
sum(my_NA, na.rm = TRUE)
```

Та же история с функцией `mean`

```{r}
mean(my_NA, na.rm = TRUE)
```

## Датафреймы

Датафрейм - один из способов хранения табличных данных в R,

Векторы одинаковой длины можно хранить вместе в виде таблицы.

```{r}
# Создадим векторы, чтобы объединить их в датафрейм.
len <- 1:9 # числовой
col <- c(rep("green", 4), rep("red", 5)) # текстовый
wid <- seq(from = 2, by = 2, to = 18) # числовой

# Создаем датафрейм
my_worms <- data.frame(Length = len,
                       Width = wid,
                       Colour = col)
```

```{r}
my_worms # печать датафрейма

class(my_worms) # смотрим, действительно датафрейм
str(my_worms) # просмотр структуры объекта
View(my_worms) # просмотр в RStudio
```

#### Задание 15

Создайте из этих векторов датафрейм под названием `Jedi` с колонками `name`, `homeworld` и `num_starships`.

```{r}
person_name <- c('Luke Skywalker', 'Darth Vader', 'Obi-Wan Kenobi', 'Yoda')
planet_name <- c('Tatooine', 'Tatooine', 'Stewjon', NA)
starships <- c(2, 1, 5, 0)
```


```{r purl=FALSE, hide_button=TRUE}
Jedi <- data.frame(name = person_name,
                   homeworld = planet_name,
                   num_starships = starships)
```

### Навигация внутри датафреймов

У каждой ячейки в датафрейме есть координаты вида `[строка, столбец]`

```{r}
my_worms[2, 3] # вторая строка в 3 столбце
my_worms[2, ] # вторая строка целиком
my_worms[1:9, 2] # строки с 1 по 9 во втором столбце
my_worms[, 2] # второй столбец целиком
```

Переменные можно извлечь при помощи оператора `$` и имени переменной

```{r}
my_worms$Length
my_worms$Width
```

Имена переменных можно использовать и внутри оператора `[]`

```{r}
my_worms[, 'Length']
my_worms[, 'Width']
```


#### Задание 16

Извлеките из датафрейма Jedi

- третью строку
- вектор имен персонажей
- значение в первом столбце четвертой строки


```{r purl=FALSE, hide_button=TRUE}
# - третью строку
Jedi[3, ]
# - вектор имен персонажей
Jedi$name
Jedi[, 'name']
Jedi[, 1]
# - значение во втором столбце четвертой строки
Jedi[4, 2]
Jedi$homeworld[4]
```

#### Задание 17

Создайте датафрейм `cups` из созданных ранее векторов `tea`, `temp`, `sugar`. Пусть переменные в нем называются заглавными буквами: `TEA, TEMP, SUGAR`

При помощи `[ ]` извлеките из `cups` данные согласно заданию. Используйте ТОЛЬКО данные из датафрейма `cups`, а не исходные векторы:

- Строки с чашками без сахара
- Строки с чашками, где 0, 3 или 5 кусков сахара
- Только данные о температуре и количестве сахара
- Цвет чая, в котором нет сахара
- Температура зеленого чая


```{r purl=FALSE, hide_button=TRUE}
cups <- data.frame(TEA = tea, TEMP = temp, SUGAR = sugar)
cups
# - Строки с чашками без сахара
cups[cups$TEA == 0, ]
# - Строки с чашками, где 0, 3 или 5 кусков сахара
cups[cups$SUGAR %in% c(0, 3, 5), ]
# - Только данные о температуре и количестве сахара
cups[, 2:3]
cups[, c('TEMP', 'SUGAR')]
# - Цвет чая, в котором нет сахара
cups$TEA[cups$SUGAR == 0]
cups[cups$SUGAR == 0, 1]
cups[cups$SUGAR == 0, 'TEA']
# - Температура зеленого чая
cups$TEMP[cups$TEA == 'G']
cups[cups$TEA == 'G', 2]
cups[cups$TEA == 'G', 'TEMP']
```

## Пакеты R и их установка.

В R похожие группы функций или функции для решения какой-то определенной задачи сгруппированы в пакеты. Часть пакетов у вас уже установлена по умолчанию вместе с базовой конфигурацией R. Какие-то нужные пакеты нам придется установить из репозитория на сайте `CRAN` или одном из его зеркал.

Выбираем в настройках источник для установки пакетов (это придется сделать только один раз). В меню Tools -> Global Options На вкладке `Packages` выбираем подходящее зеркало сайта CRAN (`CRAN mirror`). Мы рекомендуем чешские или немецкие зеркала, потому что российские часто барахлят.

Установка пакетов в систему делается один раз при помощи функции `install.packages("имя_пакета")`. Для установки пакетов с зеркала `CRAN` вы должны быть подключены к интернету. После установки пользоваться пакетами можно будет без подключения.

Для работы в этом курсе вам потребуются разные пакеты. Давайте установим некоторые из них и заодно изучим, как работает эта функция.

```{r eval=FALSE}
install.packages('ggplot2')  # установка пакета ggplot2 (графики)
```

Не пугайтесь, вам напишут много текста. Главное, чтобы в нем не было слова ERROR.

```{r eval=FALSE}
install.packages('tidyr') # установка пакета tidyr (работа с данными)
```

Пакеты можно устанавливать по одному, как вы это видели только что, а можно сразу несколько (только в этом случае немного сложнее понять, если какой-то пакет не установился).

```{r eval=FALSE}
install.packages(c('readxl', 'gridExtra', 'MASS'))
```

Самый простой способ проверить, установлен  ли пакет --- это пойти на вкладку `Packages` (в той же части окна `RStudio`, где `Help`) и набрать в поисковой строке название пакета.

Пакеты в систему придется установить один раз, но для работы с ними их придется каждый раз активировать (доставать из локальной библиотеки пакетов при помощи функции `library()`). 

Как работать с пакетами мы поговорим в следующий раз.


